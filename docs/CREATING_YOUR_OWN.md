# Creating Your Own Flutter FFI Plugin with Rust

**A complete, step-by-step tutorial**

This guide teaches you how to create a production-ready Flutter FFI plugin with Rust from scratch. By the end, you'll understand every component and be able to build your own.

## Table of Contents

1. [Understanding FFI](#understanding-ffi)
2. [Project Architecture](#project-architecture)
3. [Step-by-Step Implementation](#step-by-step-implementation)
4. [Memory Management](#memory-management)
5. [Async Operations](#async-operations)
6. [Platform Integration](#platform-integration)
7. [Best Practices](#best-practices)
8. [Common Pitfalls](#common-pitfalls)

---

## Understanding FFI

### What is FFI?

**Foreign Function Interface (FFI)** allows programs written in one language to call functions from another language. In our case:
- **Dart** (Flutter) calls functions written in **Rust**
- Communication happens through **C ABI** (Application Binary Interface)
- Dart compiles to native code, Rust compiles to native code, both speak "C"

### Why Rust + Flutter?

**Flutter advantages:**
- Beautiful, fast UI
- Hot reload
- Cross-platform widgets

**Rust advantages:**
- Memory safety without garbage collection
- Zero-cost abstractions
- Fearless concurrency
- Native performance

**Together:**
- Flutter for pixels, Rust for logic
- Best of both worlds
- Production-grade performance and reliability

### The FFI Stack

```
┌─────────────────────────────────────┐
│         Dart/Flutter App            │  <- Your UI code
├─────────────────────────────────────┤
│     Dart FFI Bindings (auto)        │  <- Generated by ffigen
├─────────────────────────────────────┤
│         C Header (auto)              │  <- Generated by cbindgen
├─────────────────────────────────────┤
│    Rust FFI Functions (#[no_mangle])│  <- Your Rust code
├─────────────────────────────────────┤
│         Rust Business Logic          │  <- Core functionality
└─────────────────────────────────────┘
```

---

## Project Architecture

### Directory Structure

```
my_plugin/
├── rust_core/              # Rust library
│   ├── src/
│   │   ├── lib.rs         # Library entry point
│   │   └── ffi/           # FFI-specific code
│   ├── Cargo.toml         # Rust dependencies
│   ├── cbindgen.toml      # C header config
│   └── build.rs           # Build script
│
└── dart_core/              # Flutter plugin
    ├── lib/
    │   └── my_plugin.dart # Dart API
    ├── pubspec.yaml       # Dart dependencies
    ├── ffigen.yaml        # Binding config
    └── <platform_dirs>/   # Android, iOS, etc.
```

### Build Pipeline

```
1. Write Rust code with #[no_mangle]
   ↓
2. cargo build → triggers build.rs
   ↓
3. build.rs → runs cbindgen → generates C header
   ↓
4. dart run ffigen → reads C header → generates Dart bindings
   ↓
5. flutter build → Cargokit compiles Rust → links to app
```

---

## Step-by-Step Implementation

### Phase 1: Rust Setup

#### 1.1 Create Rust Library

```bash
cargo new --lib rust_core
cd rust_core
```

#### 1.2 Configure `Cargo.toml`

```toml
[package]
name = "rust_core"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["staticlib", "cdylib", "rlib"]
# staticlib: iOS/macOS
# cdylib: Android/Linux/Windows
# rlib: Rust dependencies

[dependencies]
libc = "0.2"  # For C types

[build-dependencies]
cbindgen = "0.27"  # C header generation
```

**Why multiple crate types?**
- **staticlib**: iOS/macOS link statically (`.a` files)
- **cdylib**: Dynamic linking for other platforms (`.so`, `.dll`)
- **rlib**: Allows other Rust crates to depend on this

#### 1.3 Create FFI Module

```bash
mkdir -p src/ffi
```

**`src/ffi/types.rs`** - Type conversions:

```rust
use std::ffi::{c_char, CStr, CString};

// Trait for converting C strings to Rust
pub trait CstrToRust {
    fn to_native(&self) -> String;
    fn to_native_no_free(&self) -> String;
}

impl CstrToRust for *const c_char {
    // Auto-frees Dart memory
    fn to_native(&self) -> String {
        if self.is_null() {
            return String::new();
        }
        let v = unsafe {
            CStr::from_ptr(*self).to_string_lossy().into_owned()
        };
        // Free Dart-allocated memory
        unsafe { libc::free(*self as *mut libc::c_void); }
        v
    }

    // Dart keeps ownership
    fn to_native_no_free(&self) -> String {
        if self.is_null() {
            return String::new();
        }
        unsafe {
            CStr::from_ptr(*self).to_string_lossy().into_owned()
        }
    }
}

// Trait for converting Rust strings to C
pub trait RustToCstr {
    fn to_cstr(&self) -> *mut c_char;
}

impl RustToCstr for String {
    fn to_cstr(&self) -> *mut c_char {
        if self.is_empty() {
            return std::ptr::null_mut();
        }
        CString::new(self.as_str()).unwrap().into_raw()
    }
}

impl RustToCstr for &str {
    fn to_cstr(&self) -> *mut c_char {
        if self.is_empty() {
            return std::ptr::null_mut();
        }
        CString::new(*self).unwrap().into_raw()
    }
}
```

**Key Concepts:**

- **`to_native()`**: Converts C string → Rust, frees Dart memory
- **`to_native_no_free()`**: Converts but Dart keeps ownership
- **`to_cstr()`**: Converts Rust → C string, Rust allocates, Dart must free
- **`into_raw()`**: Transfers ownership to Dart (Rust won't free)

**`src/ffi/memory.rs`** - Memory management:

```rust
use std::ffi::{c_char, CString};

// Dart calls this to free Rust-allocated strings
#[no_mangle]
pub extern "C" fn free_c_string(s: *mut c_char) {
    if s.is_null() {
        return;
    }
    unsafe {
        // Takes ownership back from Dart and drops
        drop(CString::from_raw(s));
    }
}
```

**Why `#[no_mangle]`?**
- Rust mangles function names for overloading
- C doesn't support name mangling
- `#[no_mangle]` preserves exact function name for FFI

**`src/ffi/mod.rs`**:

```rust
pub mod memory;
pub mod types;

pub use memory::*;
pub use types::*;
```

#### 1.4 Add Example Functions

**`src/lib.rs`**:

```rust
pub mod ffi;

use std::ffi::c_char;
use ffi::{CstrToRust, RustToCstr};

// Simple integer function
#[no_mangle]
pub extern "C" fn sum(a: i32, b: i32) -> i32 {
    a + b
}

// String manipulation
#[no_mangle]
pub extern "C" fn reverse_string(input: *const c_char) -> *mut c_char {
    let s = input.to_native();  // Auto-frees Dart memory
    let reversed: String = s.chars().rev().collect();
    reversed.to_cstr()  // Rust allocates, Dart will free
}

// Error handling example
#[no_mangle]
pub extern "C" fn divide(
    a: i32,
    b: i32,
    error_out: *mut *mut c_char
) -> i32 {
    if b == 0 {
        if !error_out.is_null() {
            unsafe {
                *error_out = "Division by zero".to_cstr();
            }
        }
        return 0;
    }
    a / b
}
```

**FFI Function Patterns:**

1. **Simple types** (i32, f64): Direct pass
2. **Strings**: Use `*const c_char` (input), `*mut c_char` (output)
3. **Errors**: Additional `error_out` parameter
4. **Always** use `extern "C"` for C ABI
5. **Always** use `#[no_mangle]` for FFI functions

#### 1.5 Auto-Generate C Header

**`build.rs`**:

```rust
use std::env;

fn main() {
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();

    cbindgen::generate(&crate_dir)
        .expect("Unable to generate bindings")
        .write_to_file("../dart_core/src/rust_core.h");

    // Rebuild if source changes
    println!("cargo:rerun-if-changed=src/");
}
```

**What happens:**
- Every `cargo build` runs this script
- cbindgen scans Rust code for `#[no_mangle]` functions
- Generates C header automatically
- No manual header maintenance!

**`cbindgen.toml`**:

```toml
language = "C"
braces = "SameLine"
tab_width = 4
documentation = true
include_guard = "RUST_CORE_H"
include_version = true

[export]
exclude = ["internal_", "private_"]

[parse]
parse_deps = false
include = []
```

#### 1.6 Build and Test

```bash
cargo build
# Check: ../dart_core/src/rust_core.h should be created

cargo test
```

---

### Phase 2: Flutter Plugin Setup

#### 2.1 Create Flutter Plugin

```bash
flutter create --template=plugin_ffi --platforms=android,ios,macos,linux,windows dart_core
cd dart_core
```

#### 2.2 Configure Dependencies

**`pubspec.yaml`**:

```yaml
name: dart_core
description: My FFI plugin
version: 0.1.0
publish_to: 'none'

environment:
  sdk: ">=3.4.0 <4.0.0"
  flutter: ">=3.3.0"

dependencies:
  flutter:
    sdk: flutter
  ffi: ^2.1.4

dev_dependencies:
  ffigen: ^19.0.0
  flutter_test:
    sdk: flutter
  flutter_lints: ^6.0.0

flutter:
  plugin:
    platforms:
      android:
        ffiPlugin: true
      ios:
        ffiPlugin: true
      macos:
        ffiPlugin: true
      linux:
        ffiPlugin: true
      windows:
        ffiPlugin: true
```

#### 2.3 Configure ffigen

**`ffigen.yaml`**:

```yaml
name: DartCoreBindings
description: |
  Bindings for rust_core library.
output: "lib/dart_core_bindings_generated.dart"
headers:
  entry-points:
    - "src/rust_core.h"
  include-directives:
    - "src/rust_core.h"

preamble: |
  // ignore_for_file: always_specify_types
  // ignore_for_file: camel_case_types
  // ignore_for_file: non_constant_identifier_names

comments:
  style: any
  length: full
```

#### 2.4 Generate Dart Bindings

```bash
# First, ensure C header exists
ls src/rust_core.h

# Generate Dart bindings
dart run ffigen --config ffigen.yaml

# Check: lib/dart_core_bindings_generated.dart created
```

#### 2.5 Create Platform Loader

**`lib/src/platform_loader.dart`**:

```dart
import 'dart:ffi';
import 'dart:io';

const String _pluginName = 'dart_core';  // Flutter plugin name (from podspec s.name)
const String _libName = 'rust_core';     // Rust library name (from Cargo.toml)

DynamicLibrary loadLibrary() {
  if (Platform.isMacOS || Platform.isIOS) {
    // Framework is named after the Flutter plugin, not the Rust library
    return DynamicLibrary.open('$_pluginName.framework/$_pluginName');
  }
  if (Platform.isAndroid || Platform.isLinux) {
    return DynamicLibrary.open('lib$_libName.so');
  }
  if (Platform.isWindows) {
    return DynamicLibrary.open('$_libName.dll');
  }
  throw UnsupportedError('Platform: ${Platform.operatingSystem}');
}
```

**Platform specifics:**
- **macOS/iOS**: `.framework` bundle (named after the Flutter plugin from podspec `s.name`)
- **Android/Linux**: `.so` shared library (named after the Rust library from Cargo.toml)
- **Windows**: `.dll` library (named after the Rust library)

#### 2.6 Create FFI Extensions

**`lib/src/ffi_extensions.dart`**:

```dart
import 'dart:ffi';
import 'package:ffi/ffi.dart';
import '../dart_core.dart';

extension StringFfi on String {
  // Converts Dart String → C string (malloc)
  Pointer<Char> toPtr() =>
      toNativeUtf8(allocator: malloc).cast<Char>();
}

extension PointerFfi on Pointer<Char> {
  // Converts C string → Dart String, frees Rust memory
  String toStr() {
    if (this == nullptr) return '';
    final dartString = cast<Utf8>().toDartString();
    bindings.free_c_string(this);
    return dartString;
  }

  // Converts without freeing (for manual management)
  String toStrNoFree() {
    if (this == nullptr) return '';
    return cast<Utf8>().toDartString();
  }
}
```

**Usage:**
```dart
// Easy API
final result = bindings.reverse_string('hello'.toPtr()).toStr();

// Instead of:
final inputPtr = 'hello'.toNativeUtf8(allocator: malloc).cast<Pointer<Char>>();
final resultPtr = bindings.reverse_string(inputPtr);
final result = resultPtr.cast<Utf8>().toDartString();
bindings.free_c_string(resultPtr);
malloc.free(inputPtr);
```

#### 2.7 Create Main API

**`lib/dart_core.dart`**:

```dart
library dart_core;

import 'dart:ffi';
import 'package:flutter/foundation.dart';

import 'dart_core_bindings_generated.dart';
import 'src/ffi_extensions.dart';
import 'src/platform_loader.dart';

export 'dart_core_bindings_generated.dart';
export 'src/ffi_extensions.dart';

final DynamicLibrary _dylib = loadLibrary();
final DartCoreBindings bindings = DartCoreBindings(_dylib);

void initDartCore() {
  debugPrint('DartCore initialized');
}

// High-level API
class DartCore {
  DartCore._();

  static int sum(int a, int b) {
    return bindings.sum(a, b);
  }

  static String reverseString(String input) {
    return bindings.reverse_string(input.toPtr()).toStr();
  }

  static int? divide(int a, int b) {
    final errorPtr = calloc<Pointer<Char>>();
    final result = bindings.divide(a, b, errorPtr);

    if (errorPtr.value != nullptr) {
      final error = errorPtr.value.toStr();
      calloc.free(errorPtr);
      throw Exception(error);
    }

    calloc.free(errorPtr);
    return result;
  }
}
```

---

### Phase 3: Platform Integration with Cargokit

#### 3.1 Add Cargokit

**Option A: During Development (Quick)**
```bash
cd dart_core
git clone https://github.com/irondash/cargokit.git
```

**Option B: For Publishing (Recommended)**
```bash
# From your project root (not dart_core)
git subtree add --prefix dart_core/cargokit \
  https://github.com/irondash/cargokit.git main --squash
```

Use Option A for quick experimentation. Use Option B when creating a template or plugin to publish, so users get cargokit automatically without submodules.

**Why Cargokit?**
- Automatically compiles Rust for target platform
- Handles NDK, cross-compilation, caching
- Works with Gradle, CocoaPods, CMake
- Zero configuration for users

#### 3.2 Android Setup

**`android/build.gradle`**:

```gradle
group = "com.example.dart_core"
version = "1.0"

buildscript {
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath("com.android.tools.build:gradle:8.1.0")
    }
}

rootProject.allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

apply plugin: "com.android.library"

android {
    if (project.android.hasProperty("namespace")) {
        namespace = "com.example.dart_core"
    }

    compileSdk = 34
    ndkVersion = android.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }

    defaultConfig {
        minSdk = 21
    }
}

// Cargokit integration
apply from: "../cargokit/gradle/plugin.gradle"

cargokit {
    manifestDir = "../../rust_core"  // Path to Cargo.toml
    libname = "rust_core"             // Library name
}
```

#### 3.3 iOS Setup

**`ios/dart_core.podspec`**:

```ruby
Pod::Spec.new do |s|
  s.name             = 'dart_core'
  s.version          = '0.1.0'
  s.summary          = 'My FFI plugin'
  s.homepage         = 'https://example.com'
  s.license          = { :file => '../LICENSE' }
  s.author           = { 'Your Name' => 'your@email.com' }
  s.platform = :ios, '12.0'

  s.source           = { :path => '.' }
  s.source_files     = 'Classes/**/*'

  # Cargokit build script
  s.script_phase = {
    :name => 'Build Rust library',
    :script => 'sh "$PODS_TARGET_SRCROOT/../cargokit/build_pod.sh" ../../rust_core rust_core',
    :execution_position => :before_compile,
    :input_files => ['${BUILT_PRODUCTS_DIR}/cargokit_phony'],
    :output_files => ["${BUILT_PRODUCTS_DIR}/librust_core.a"],
  }

  s.pod_target_xcconfig = {
    'DEFINES_MODULE' => 'YES',
    'EXCLUDED_ARCHS[sdk=iphonesimulator*]' => 'i386',
    'OTHER_LDFLAGS' => '-force_load ${BUILT_PRODUCTS_DIR}/librust_core.a',
  }
end
```

**Create `ios/Classes/dart_core.c`** (empty file):
```bash
touch ios/Classes/dart_core.c
```

This empty `.c` file is required by CocoaPods for the `s.source_files` pattern. The actual FFI symbols come from the Rust static library via `-force_load`.

#### 3.4 macOS Setup

Same as iOS:
1. Copy the podspec to `macos/dart_core.podspec`
2. Change `s.platform = :osx, '10.14'`
3. Remove the `EXCLUDED_ARCHS` line (macOS doesn't need it)
4. Create `macos/Classes/dart_core.c` (empty file)

#### 3.5 Linux Setup

**`linux/CMakeLists.txt`**:

```cmake
cmake_minimum_required(VERSION 3.10)
set(PROJECT_NAME "dart_core")
project(${PROJECT_NAME} LANGUAGES CXX)

set(PLUGIN_NAME "dart_core_plugin")

add_library(${PLUGIN_NAME} SHARED
  "../src/rust_core.c"
)

target_link_libraries(${PLUGIN_NAME} PRIVATE flutter)
target_link_libraries(${PLUGIN_NAME} PRIVATE PkgConfig::GTK)

# Cargokit integration
include(../cargokit/cmake/cargokit.cmake)
apply_cargokit(${PLUGIN_NAME} ${CMAKE_CURRENT_SOURCE_DIR}/../../rust_core rust_core)
```

#### 3.6 Windows Setup

Similar to Linux, adjust for Windows-specific settings.

---

## Memory Management

### The Golden Rules

1. **Who allocates, who frees**
   - Dart allocates → Rust frees (or Dart frees if manual)
   - Rust allocates → Dart frees

2. **Ownership transfer**
   - `into_raw()` transfers ownership
   - `from_raw()` takes ownership back

3. **Safety first**
   - Always check for null
   - Use traits for safety
   - Prefer automatic over manual

### Memory Flow Example

```
Dart: "hello".toPtr()
  ↓ malloc allocates
Rust: input.to_native()
  ↓ reads string, calls libc::free(input)
Rust: result.to_cstr()
  ↓ CString::new().into_raw() - transfers ownership
Dart: result.toStr()
  ↓ reads string, calls bindings.free_c_string(result)
Rust: free_c_string()
  ↓ CString::from_raw(s), drops
```

### Debugging Memory Issues

**Valgrind (Linux/macOS):**
```bash
valgrind --leak-check=full flutter test
```

**AddressSanitizer:**
```bash
# In rust_core/Cargo.toml
[profile.dev]
opt-level = 0
debug = true

# Build with sanitizer
RUSTFLAGS="-Z sanitizer=address" cargo build
```

---

## Async Operations

### The Problem with Callbacks

**❌ DON'T** use callbacks from Rust tokio threads to Dart:
```rust
// This will CRASH! Dart callbacks must be invoked from Dart's thread
tokio::spawn(async move {
    let result = do_work().await;
    dart_callback(result);  // ❌ CRASH!
});
```

### The Solution: Isolated Port Pattern

**✅ DO** use isolated `DartPort` per call - no global state!

**Step 1: Add dependency**
```toml
# rust_core/Cargo.toml
[dependencies]
irondash_dart_ffi = "0.2"
num_cpus = "1"
```

**Step 2: Initialize Dart API (once)**
```rust
// rust_core/src/ffi/dart_port.rs
use std::sync::Once;

static INIT: Once = Once::new();

#[no_mangle]
pub extern "C" fn init_dart_api(data: *mut std::ffi::c_void) -> bool {
    INIT.call_once(|| {
        irondash_dart_ffi::irondash_init_ffi(data);
    });
    true
}
```

**Step 3: Configure parallel runtime**
```rust
// rust_core/src/ffi/runtime.rs
use tokio::runtime::Runtime;

static RUNTIME: Lazy<Runtime> = Lazy::new(|| {
    tokio::runtime::Builder::new_multi_thread()
        .worker_threads(num_cpus::get())  // Use all CPU cores
        .thread_name("app_core")
        .enable_all()
        .build()
        .expect("Failed to create Tokio runtime")
});

pub fn spawn<F>(future: F)
where
    F: Future<Output = ()> + Send + 'static,
{
    RUNTIME.spawn(future);
}
```

**Step 4: Write async Rust function**
```rust
use irondash_dart_ffi::DartPort;

#[no_mangle]
pub extern "C" fn fetch_data_async(url: *const c_char, port: i64) {
    let url = url.to_native();
    let dart_port = DartPort::new(port);  // Create from parameter

    crate::ffi::spawn(async move {
        // Do async work - runs on worker thread pool
        tokio::time::sleep(Duration::from_millis(500)).await;
        let result = format!("Data from: {}", url);

        // Send directly to isolated port
        dart_port.send(result);
    });
}
```

**Step 5: Create generic Dart helper**
```dart
// lib/src/async_helper.dart
import 'dart:async';
import 'dart:ffi';
import 'dart:isolate';

Future<T> ffiAsync<T>(
  void Function(int port) rustCall,
  T Function(dynamic message) parser,
) {
  final port = ReceivePort();  // Create unique port
  final completer = Completer<T>();

  port.listen((message) {
    try {
      completer.complete(parser(message));
    } catch (e) {
      completer.completeError(e);
    } finally {
      port.close();  // Auto-dispose after receiving
    }
  });

  rustCall(port.sendPort.nativePort);  // Pass port to Rust
  return completer.future;
}
```

**Step 6: Use in your API**
```dart
// lib/app_core.dart
class AppCore {
  static Future<String> fetchDataAsync(String url) {
    return ffiAsync(
      (port) => bindings.fetch_data_async(url.toPtr(), port),
      (msg) => msg as String,
    );
  }
}
```

**Step 7: Call with await**
```dart
// Clean and simple!
final result = await AppCore.fetchDataAsync('https://api.example.com');
print('Got: $result');

// With error handling
try {
  final data = await AppCore.processAsync('input');
} catch (e) {
  print('Error: $e');
}
```

### How It Works

1. Dart creates **isolated** `ReceivePort` for this specific call
2. Passes port to Rust function
3. Rust spawns async task on **multi-threaded runtime** (truly parallel)
4. Rust sends result directly to that specific port
5. Dart receives, completes Future, **closes port immediately**
6. Each call completely isolated - no shared state!

### Parallel Execution

Multiple async calls run **truly in parallel** across CPU cores:

```dart
// All 3 run simultaneously on different cores
await Future.wait([
  AppCore.fetchDataAsync('url1'),  // Core 1
  AppCore.fetchDataAsync('url2'),  // Core 2
  AppCore.fetchDataAsync('url3'),  // Core 3
]);
```

**Key advantages:**
- ✅ No global state or request IDs
- ✅ Each call isolated (own port)
- ✅ Port auto-disposes
- ✅ Truly parallel across all CPU cores
- ✅ No threading issues
- ✅ Clean await syntax
- ✅ 60% less code than request ID pattern

---

## Blocking Operations with Isolates

For CPU-intensive blocking operations, use Dart isolates to prevent UI freezing.

### When to use

| Pattern | Use Case | Example |
|---------|----------|---------|
| `ffiAsync` | Async I/O, network, tokio | `await fetchData()` |
| `ffiCompute` | CPU-intensive blocking | `await fibonacci(40)` |

### Step 1: Create blocking Rust function

```rust
// rust_core/src/examples/blocking.rs
#[no_mangle]
pub extern "C" fn fibonacci(n: u64) -> u64 {
    // Blocking, recursive, CPU-intensive
    match n {
        0 => 0,
        1 => 1,
        _ => fibonacci(n - 1) + fibonacci(n - 2),
    }
}

#[no_mangle]
pub extern "C" fn heavy_computation(iterations: u64) -> u64 {
    let mut sum: u64 = 0;
    for i in 0..iterations {
        sum = sum.wrapping_add(i * i);
    }
    sum
}
```

### Step 2: Create isolate helper

```dart
// lib/src/isolate_helper.dart
import 'dart:isolate';
import 'package:flutter/foundation.dart';

Future<R> ffiCompute<M, R>(R Function(M) callback, M message) {
  if (kIsWeb) {
    return Future.value(callback(message));
  }
  return compute(callback, message);
}
```

### Step 3: Wrap in AppCore

```dart
// lib/app_core.dart
class AppCore {
  static Future<int> fibonacci(int n) {
    return ffiCompute(_fibonacciWorker, n);
  }

  static int _fibonacciWorker(int n) {
    return bindings.fibonacci(n);  // Blocking call
  }

  static Future<int> heavyComputation(int iterations) {
    return ffiCompute(_heavyWorker, iterations);
  }

  static int _heavyWorker(int iterations) {
    return bindings.heavy_computation(iterations);
  }
}
```

### Step 4: Use with await

```dart
// UI stays responsive - runs on separate isolate
final result = await AppCore.fibonacci(40);
print('Result: $result');

// Multiple computations in parallel
await Future.wait([
  AppCore.fibonacci(35),
  AppCore.fibonacci(36),
  AppCore.heavyComputation(1000000),
]);
```

### How it works

1. Dart spawns new isolate (separate thread)
2. Isolate calls blocking Rust function
3. Main thread (UI) stays responsive
4. Result sent back via SendPort
5. Future completes with result

### Comparison

```dart
// ❌ BAD - blocks UI thread
int result = bindings.fibonacci(40);  // UI freezes!

// ✅ GOOD - runs on isolate
int result = await AppCore.fibonacci(40);  // UI responsive!
```

### Benefits

- ✅ UI stays responsive
- ✅ True parallelism (separate CPU core)
- ✅ Clean await syntax
- ✅ Automatic error handling
- ✅ Web-safe (falls back to sync on web)

---

## Best Practices

### Rust Side

✅ **DO:**
- Use `#[no_mangle]` on all FFI functions
- Use `extern "C"` for C ABI
- Always check for null pointers
- Use traits for type conversions
- Handle errors explicitly
- Document FFI boundary

❌ **DON'T:**
- Use `unwrap()` or `expect()` in FFI
- Pass complex Rust types directly
- Assume pointers are valid
- Ignore memory ownership

### Dart Side

✅ **DO:**
- Free all allocated memory
- Check for null before dereferencing
- Use extensions for convenience
- Wrap raw bindings in high-level API
- Test on all platforms

❌ **DON'T:**
- Ignore returned pointers
- Assume memory is managed
- Skip error checking
- Mix manual and automatic freeing

---

## Common Pitfalls

### 1. Forgetting `#[no_mangle]`

```rust
// ❌ Wrong - function name will be mangled
pub extern "C" fn my_function() { }

// ✅ Correct
#[no_mangle]
pub extern "C" fn my_function() { }
```

### 2. Not Freeing Memory

```dart
// ❌ Memory leak
final result = bindings.get_string();
// Never freed!

// ✅ Correct
final result = bindings.get_string().toStr();
// Automatically freed
```

### 3. Using Rust Types in FFI

```rust
// ❌ Wrong - Vec can't cross FFI
#[no_mangle]
pub extern "C" fn get_items() -> Vec<String> { }

// ✅ Correct - return JSON string instead
#[no_mangle]
pub extern "C" fn get_items() -> *mut c_char {
    let items = vec!["item1", "item2", "item3"];
    serde_json::to_string(&items).unwrap().to_cstr()
}
```

### 4. Platform-Specific Paths

```rust
// ❌ Device-specific
let path = "/Users/myuser/openssl";

// ✅ Generic
let path = env::var("OPENSSL_DIR").ok();
```

---

## Next Steps

You now understand:
- ✅ FFI fundamentals
- ✅ Rust-Dart communication
- ✅ Memory management
- ✅ Platform integration
- ✅ Best practices

**Continue learning:**
1. Study the app_core template code
2. Build your own custom plugin
3. Read [Rust FFI Nomicon](https://doc.rust-lang.org/nomicon/ffi.html)
4. Check [Dart FFI docs](https://dart.dev/guides/libraries/c-interop)
5. Join Flutter and Rust communities

---

**You're ready to build production FFI plugins!** 🚀

Questions? Open an issue or discussion on GitHub.